* This is a introduction of the basic concept of CSP and how to use it in Clojure

** This way of convey belt is not efficient at all

#+begin_src clojure :tangle intro-to-csp.clj
(ns tbaldridge-clojure-lecture.intro-to-csp
    (:require [clojure.core.async :as a]))
(comment
(-> (create-frame)
    (add-body)
    (map add-tire (make-tire 5))
    (add-engine)
    (ship-car))
)
#+end_src

** About `->` macro
   threads the expr through the forms. Inserts x as the second item in the first form, making a list of it if it is not a list already.
   If there are more forms, inserts the first form as the second item in second form, etc. This code is from conj.io

#+begin_src clojure :tangle intro-to-csp.clj
(def c 5)
(-> c (+ 3) (/ 2) (- 1))
(use 'clojure.walk)
(macroexpand-all '(-> c (+ 3) (/ 2) (- 1))) ; => (- (/ (+ c 3) 2) 1)
#+end_src

** CSP consists os two elements
- Processes = In Cloure, Go block or Thread
- Queues = Channels
  - have buffers
  - dropping buffer: drop newest input
  - sliding buffer: drop oldest input

** Processes communicates each other via Channels

#+begin_src clojure :tangle intro-to-csp.clj
(comment
                    (create-frame)               ;; each form is processes
                        |
                        V
                    (add-body)
                        |    (make-tire 5)
                        |         |  ;; faster , buffer size = 6000
                        V         V
(combine-tires-with-car) (combine-tires-with-car) ;; Use multiple processes for better performance
                        |   ;; slower
                        V
                    (add-engine)
                        |   ;; slower
                        V
                    (ship-car)
)
#+end_src

** Clojure Way for CSP

#+begin_src clojure :tangle intro-to-csp.clj
(def c (a/chan))
(def a (a/chan))
(a/put! c "hello" (fn [_] (println "Done Sending")))
(a/take! c (fn [val] (println val))

(a/go
  (a/>! c "Hello")
  (a/>! c "World"))

(a/go
  (println (a/<! c))
  (println (a/<! c))))

;; alt! is for fan-in and timeout to wait is available
(println (a/alt! [c a (a/timeout 1000)]))
#+end_src

** CSP paper does not mention about buffer but with processes, creating buffers is possible
#+begin_src clojure :tangle intro-to-csp.clj
(defn buffer [from]
    (let [ret (a/chan)]
        (a/go
            (while true
                (a/>! ret (a/<! from))
        ret))))

(def c (a/chan))
(def a (buffer c))
(def b (buffer a))

#+end_src
