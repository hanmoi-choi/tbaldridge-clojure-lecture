* Clojure async episode 1
#+begin_src clojure :tangle clojure-async.clj
(ns tbaldridge-clojure-lecture.clojure-async
  (:require [clojure.core.async :as a :refer [>!! <!! >! <!]]))
#+end_src

** Funciton with channels naming convention
- *<* input channel as argument
- *>* output channel as argument

** about =>!!= and =<!!=
- This is running out of *go* macro and blocking
#+begin_src clojure :tangle no
(ch (a/chan)) ; ch' size is 1
(>!! ch 43)   ; here thread will be blocked
(<!! ch)      ; This will not be executed
#+end_src

** So use =put!= and =take!= which is not blocking but parking

** We are going to implement to run funcitons in multiple precesses

#+begin_src clojure :tangle clojure-async.clj
(let [ch (a/chan 2)]      ;at first time created ch with (a/chan) and blocked :()
  (>!! ch 43)
  (<!! (pipeline< [4 inc  ; run inc with 4  processes
                   1 dec
                   2 dec
                   3 str]
                  ch)))


(defn to-proc< [in]
  (let [out (a/chan 1)]
    (a/pipe in out)   ; pipe creates new processes -> go block
    out))

(defn pipeline<
  "docstring"
  [desc c]
  (let [p (partition 2 desc)]  ; check *partition* fun
    (reduce
      (fn [prev-c [n f]]
        (-> (for [_ (range n)]
              (->
                (a/map< f prev-c) ;like *map* but second args are chan
                to-proc<))
            (a/merge)))           ; pan-in
      c
      p)))
#+end_src
