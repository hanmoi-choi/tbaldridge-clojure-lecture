* I would like to exercise and remember about tranducer
** This is from this site
- [[http://elbenshira.com/blog/understanding-transducers/][Really good explanation for Tranducer]]

** Power of reduce
#+begin_src clojure :tangle no
(map inc (range 10))
(filter even? '(1 2 3 4 5 6 7 8 9 10))

(defn map-inc-reducer [res in]
  (conj res (inc in)))

(reduce map-inc-reducer [] (range 10))

(defn map-reducer
  [f]
  (fn [res in]
    (conj res (f in))))
;; (map-reducer inc) == (map-inc-reducer)
(reduce (map-reducer inc) [] (range 10))

(defn filter-even-reducer
  [result input]
  (if (even? input)
    (conj result input)
    result))
(reduce filter-even-reducer [] '(1 2 3 4 5 6 7 8 9 10))

(defn filter-reducer
  [f]
  (fn [res input]
    (if (f input)
      (conj res input)
      res)))

#+end_src

** Another step in abstraction
*** codes below have a common part *conj*, which is reducing funciton

#+begin_src clojure :tangle no
(defn map-reducer
  [f]
  (fn [result input]
    (conj result (f input))))

(defn filter-reducer
  [predicate]
  (fn [result input]
    (if (predicate input)
      (conj result input)
      result)))
#+end_src

** Arrivaing at Tranducer
*** Let's pass *reducing fuction* as argument
- =(reduce conj [] (range 10))= here, *conj* is reducing function and its type is *(result, input) -> result*

#+begin_src clojure :tangle no
(defn mapping
  [f]
  (fn [reducing]
    (fn [result input]
      (reducing result (f input)))))

(defn filtering
  [predicate]
  (fn [reducing]
    (fn [result input]
      (if (predicate input)
        (reducing result input)
        result))))
#+end_src

*** Arriving at transducers
**** both of them's type is (result, input) ⟶ result
#+begin_src clojure :tangle no
((mapping inc) conj)
((filtering even?) conj).
#+end_src

**** so we could compose two functions like this
- =((filtering even?) conj)='s return type is *(result, input) ⟶ result*
- =(mapping inc)='s expected arg type is *(result, input) ⟶ result*
#+begin_src clojure :tangle no
((mapping inc) ((filtering even?) conj))
#+end_src

** Summary
- *Tranducer* is a function which type is *(result, input ⟶ result) ⟶ (result, input ⟶ result)*
- So =(mapping inc)= is +Tranducer+

** Appendix
*** Tranducer is coming in Clojure 1.7.0
*** Transducer can work across core.async channels
#+begin_src clojure :tangle no
(defn square [x] (* x x))

(def xform
  (comp
    (filter even?)
    (filter #(< % 10))
    (map square)
    (map inc)))

(def my-chan (async/chan 1 xform))

; Waiting for an item to print...
(async/take! my-chan println)

(async/put! my-chan 3)
; nothing printed to screen, since 3 is not even

(async/put! my-chan 4)
; "17" printed to screen, since 4 is even and less than 10
#+end_src

Note: Did you know this? I didn't.
First, note that channel buffers are linked lists underneath (in fact, java.util.LinkedLists).
When you put an item into a channel, the internal helper method add! is called to add your item into the buffer.

But if a transducer xform is supplied, core.async will use add! as the reducing function passed into xform:
#+begin_src clojure :tangle no
(xform add!) ;; add!'s type is (result, input) -> input
#+end_src
